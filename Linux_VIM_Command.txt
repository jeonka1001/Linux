<grep> 
- Global REgex print 의 약자, 파일 전체에서 정규 표현식과 일치하는 패턴을 출력하는 명령어
- grep[옵션...]regex [파일명..]
- -c regex : 패턴이 일치하는 해으이 개수를 출력 ex) grep -c 'zip' sample.txt ->> 5
- -n : 패턴이 일치하는 행의 번호를 함깨 출력 ex) grep -n 'zip' sample.txt 
- -i : 패턴의 대소문자 구분 없이 같으면 출력
- -l : 패턴이 포함된 "파일"을 출력 ex) grep -l 'zip' *.txt
- -L : 패턴이 포함되지 않는 "파일" 이름 출력 ex) grep -L 'zip' *.txt
- -r(recursive) : 하위 디렉터리 파일까지 패턴 검색

<정규 표현식>
- Regular Expression 또는 Regex 라고 하며 특정 규칙을 가진 문자열의 집합을 표현하는데 사용하는 형식 언어.

[메타문자]
- 일반적인 문자들을 리터럴 이라고함. 즉, 문자 그대로 해석됨.
- 메타 문자는 정규 표현식에 단순 문자로 해석되는 것이 아니라 다른 의미로 해석되는 문자
  ex) ^ & . [] {} - ? + () | ..
- 메타 문자는 혼용해서 사용이 가능하다.
[ 기본 정규 표현식 ] 
1 . : 임의의 1개의 문자와 일치하는 문자  ex) grep -w '.zip' *
- 1개 이상도 사용 가능 ->> grep -w '..zip' * 또는 grep -w 'g..z.p' * 도 가능
** 만약 .이 문지 그대로(리터럴)로 검색되게 하고 싶다면? ->> grep -w '\.zip' * '\' 를 이용한다!

2. ^ : 특정 패턴으로 시작되는 것을 검색할 때 사용
- zip 으로 시작되는 패턴을 찾고싶은 경우? -> '^zip' ex) grep '^zip' sample.txt

3. $ : 특정 패턴으로 끝나는 것을 검색할 경우
- zip 으로 끝나는 패턴을 찾고싶은 경우 -> 'zip$' ex) grep 'zip$' sample.txt

4. ^단어$ : 특정 단어만 포함되어 있는 행을 검색
- zip만 포함된 행을 검색 ex) grep -w '^zip$' sample.txt
- ^$ 의 의미는 ->> 아무런 문자가 없는 공백 라인을 의미

5. [] : 문자 클래스란 문자 집합 중에 특정 문자와 일치하는지를 확인하는 메타문자
- 셸에서 [] 와일드 카드와 동일한 개념
- b나 g로 시작하는 zip 패턴을 찾고 싶은경우 ex) grep '[bg]zip' sample.txt

- - : 문자 집합의 범위를 표현하기 위해 사용 ex) grep '[0-9][0-9]' sample.txt
** 그러나 유닉스 전용 표기법이므로 일부 리눅스에서 정상작동하지 않을 수 있음.
따라서 grep '[[:digit:]][[:digit:]]' sample.txt 이렇게 표기하는것을 권장한다.
- grep '^[[:upper:]]' sample.txt : 대문자로 시작하는 패턴 찾기
- 해당문자 집합 이외의 집합을 표현하려면 패턴 내부에 ^ 를 사용한다.
  ex) grep '^[^[:lower:]]' sample.txt : [^[:lower:]] 로 시작하는 것들 출력
					  ^~~~ 소문자가 '아닌' 
- 복수 집합도 표현 가능 
- grep '^[[:alnum:]]' sample.txt << POSIX 에서 사용권장
  ( == grep '^[0-9A-Za-z]' sample.txt << 위와 같은 표현 )

6. * : * 앞의 문자가 0개 이상 반복되는 것을 표현하는 메타 문자
ex) a*b -> ab aab aaab aaaab aaaaab .....

[ 확장 정규 표현식 ]
- grep 의 경우 기본 정규 표현식만 해석이 가능하므로 확장 정규 표현식을 해석하려면 -E 옵션을 줘야한다.
- 또는 egrep 을 사용한다. ( 사용법은 grep 과 동일 )

1. | : 대안 의 개념 (OR)
- 어떤 파일에서 bz나 gz 가 포함되어 있는 패턴을 찾고 싶은경우 ex) grep -E 'bz|gz' sample.txt

2. () : 특정 패턴을 찾기 위한 메타 문자가 아닌 다른 정규 표현식의 요소들을 결합할 때 사용.
- gz 나 bz 로 시작하는 패턴을 찾고 싶은 경우 ex) egrep '^bz|^gz' sample.txt
						^~~~~ '^(bz|gz)' 로 간단하게 표현 가능
3. ? : ? 앞의 문자가 있거나 없을 때의 패턴을 찾을 때 사용 ->> 앞의 문자가 0 또는 1 회 반복
- ex) echo "abc abacs abbccs" | egrep "abc|aba|abb"
					^~~~ ab? 로간단히 표현 가능
4. + : 앞의 문자가 1번 이상 반복하는 것을 의미
- a+b : ab aab aaab .... 

5. {} : 아래 정의에 따른 패턴을 포함한 행 출력
- {N} : 앞의 문자가 정확하게 N번 반복 ex) egrep "w{3}" 파일명 >> www..... 인 단어를 찾는다.
	ww, wwww 는 출력되지 않는다.
- {min,} : 앞의 문자가 최소한 min 번 이상 반복 하는 패턴을 찾기
	 ex) egrep "w{1,}" 파일명 >> w.., ww..., www..., ..... 출력
- {min,max} : 앞의 문자가 min 번 이상 max 번 이하 반복하는 패턴
	ex) egrep "w{1,2}" 파일명 >> w..., ww,... ( www는 출력 x )

** 메타 문자는 혼용해서 사용이 가능하다.**

< 파일 관리 > 
[[파일 보관]]
- 파일 작업을 하다보면 다수의 파일을 하나의 파일로 묶어야 하는 경우가 생김.
- 이처럼 다수의 파일을 하나이 파일로 묶는 작업을 아카이빙이라 한다.
- 보통 백업을 하기 위해 사용한다.
[mode]
  c : 아카이브 생성
  x : 아카이브 해제
  r : 아카이브에 추가
  t : 아카이브 내용 보기
  z : 아카이빙과 동시에 압축을 실행
[option]
  f 파일명 : 아카이브의 이름 설정
  v : 작업 내용을 자세히 출력
** 주의 모드와 옵션을 같이 사용할 경우 반드시 mode 가 option 보다 먼저 나와야 한다.
- 아카이브 파일 생성시, 확장자가 없지만 가독성을 이유로 .tar 를 사용하는 것이 관례
- 현재 디렉터리 안의 모든 파일을 묶어 text.tar 파일로 생성하는 방법 ->> tar cvf test.tar *
- 아카이브 파일의 내용을 확인 ->> tar tf test.tar
- 아카이브 파일을 해제하고 싶은 경우 ->> tar xvf test.tar

[압축]
- gzip, bzip2 : 리눅스에 제공하는 무손실 압출 프로그램 또는 명령어
- gzip : Gnu zip 의 약자로 유닉스 시스템에서 쓰이던 압축 프로그램을 대체하기 위해 구현된 오픈 소스 프로그램
- 다수의 파일을 하나로 압축 기능은 없다.

사용방법 : gzip 파일명 - 압축된 파일에 대하여 확장자는 없지만 관례적으로 가독성을 위해 .tar 를 쓴다.
- 해제는 gzip -d 파일명 or gunzip 파일명
- 다른 명령어에서 출력된 결과를 바로 압축하고 싶다면 파이프라인과 리다이렉션 사용 가능
  ex) ls -R / | gzip > ls.txt.gz

-일반적으로 압축은 하나 이상의 파일에 대해 수행한다.
-하지만 매번 tar와 gzip 명령어를 개별적으로 사용하는 것이 불편하다
-이를 해결하려면 파이프라인과 리다이렉션을 사용하면 된다. ex )tar cv | gzip > test.tar.gz

- 하지만 이는 완벽한 해결책이 아니다. 따라서 z 옵션 사용ex)tar cvzf test.tar.gz test.tar.gz *.txt
						    ^~~ z 옵션으로 묶은 후에 바로 압축을 수행한다.
** z 옵션을 통해 아카이빙과 압축을 한번에 할 경우 확장자는 관례적으로 .tar.gz 를 사용한다.
   ->> tgz  == .tar.gz 의 축약된 표현

<<[[vi 단축키]]>>
- vi의 모드 : 명령모드 , 편집모드 , ex 모드
i : insert 커서 위치에 글자 삽입, I : 행 맨앞 이동 후 편집모드
a : append 커서 다음 위치에 글자 삽입, A : 행 맨뒤 이동 후 편집모드
o : 커서 아래에 새로운 행을 삽입, O : 커서 위에 새로운 행을 삽입
w : 파일 저장 , w! : 파일 강제 저장, q : 종료 , q! : 강제종료, wq or x : 저장과 종료를 동시에 수행

x : 현재 커서의 문자 1개를 삭제 ( 단 개행문자는 삭제 할 수 없음 )(잘라내기)
dd : 현재 행을 삭제, D : 현재 커서부터 행의 끝부분까지 삭제(잘라내기)
J : 현재 행에 위치한 개행 문자를 삭제(잘라내기)

yy 또는 Y : 현재 행을 복사, p(paste) : 현재 행에 붙여 넣는다. 개행 문자가 포함된경우 현재 행의 아래에 붙는다.
u (undo) : 바로 이전에 수행했던 명령 하나를 취소 , CTRL + R(redo) : 바로 이전 취소 명령 다시 실행

^ : 행의 맨 앞으로 이동, $ : 행의 맨 뒤로 이동
gg : 문서의 처음으로 이동, G : 문서의 끝으로 이동
w(word) : 커서를 다음으로 이동하되 단어 단위로 이동, b(backward) : 커서를 이전으로 이동하되 단어 단위로 이동
ctrl + b : 한 화면 위로 스크롤 , ctrl + f : 한 화면 아래로 스크롤 
ctrl + u : 한 화면 반만 스크롤 , ctrl + d : 한 화면 반만 아래로 스크롤


[비주얼 모드(블럭지정)]
v(비주얼 모드 실행) : 블럭 지정 가능 , V : 행단위 블럭지정, CTRL + V(v) : 열단위 블럭지정
블럭 지정 후 shift + ` 누를 시 대소문자 변경

[[치환하기]]
- ex 모드에서 수행하기 ( 형식 : 범위s/치환 할 문자열/ 치환 될 문자열/ 옵션
%s/hello/good/g  : 문서 전체의 hello 를 good 으로 변경

[윈도우 모드]
- Ctrl + w(prefix) : 수직으로 잘라내기
- Ctrl + w + s : 수직 분할
- Ctrl + w + v : 수직 분할
- Ctrl + c : 창 닫기 , ctrl + hjkl ( 좌 하 상 우 )
- sp 파일명 : 수평분할 , vs 파일명 : 수직분할

- set autoindent : 자동 들여쓰기 모드 / - set cindent : 코딩할 때 사용 

해당하는 명령어의 단축키 보기 : section번호 + K  (1번의 경우 K만 눌러도 됨)

vim ~/.vimrc 를 켜면 소스코드를 작성시 화면을 커스터마이징 할 수 있다.

