<권한>
-rw-rw-r-- / - rw- rw- r-- <<-나머지 권한
 소유자의 권한~~^   ^~~그룹의 권한
rwx -> r: 읽기 권한 / w : 쓰기 권한 / x : 실행 권한/ - : 권한 없음
권한	파일 		디렉터리
r 	파일 읽기 허용  디렉터리 내용을 읽을 수 있음 (ls)
w 	파일 쓰기 허용  디렉터리 내에 파일을 생성, 삭제, 이름변경 가능
x 	파일 실행 허용  디렉터리 안으로 진입을 허용, cd 가능

<파일 권한 변경 방법>
chmod 명령어 사용 - 관리자, 파일 소유자 만 사용 가능

<권한 설정 방법>
- 8진법 사용 : 정수를 사용하여 변경
ex) rw- rw- r-- 
    110 110 100 ->> 664 => chmod 664 파일명
장점 : 다수의 권한을 한 번에 설정할 수 있다.
단점 : 일부 권한만을 설정할 수 없으며, 다른 권한이 변경될 수 있음

- 문자 사용(권장) 
구분 		문자 	의미
카테고리	u	파일 소유자(user)
		g	소유자가 속한 그룹(group)
		o 	이 외의 나머지(other)
		a 	전체 사용자(all)
연산자 기호	+ 	권한 추가
		-	권한 삭제
		= 	권한 설정
접근권한문자	r 	읽기
		w 	쓰기
		x 	실행 
사용 예시 : 
uex : 소유자에게 실행 권한을 부여 
u-w : 소유자로부터 쓰기 권한을 제거 
g+rw : 그룹에게 읽기/쓰기 권한을 부여
o+wx : 이외의 사용자로부터 쓰기/실행 권한을 제거
ug-x : 소유자와 그룹으로부터 실행 권한을 제거
+x : 모든 사용자에게 실행 권한을 부여
u = rwx : 소유자에게 읽기/쓰기/실행 권한을 설정
u+w,go-w : 소유자에게 쓰기 권한을 부옇고 그룹과 나머지는 쓰기 권한을 제거

문자를 사용할 경우의 장점 : 다른 속성은 그대로 유지한 채 특정 속성만 수정할 수 있음. -> 가독성이 높아진다.
단점 : 수정할 속성이 많아질 경우 다소 복잡해진다.

umask : 리눅스에서 파일이 생성될 때, 주어진 기본 권한을 제어하기 위한 명령어
- 파일 생성시 기본적으로 모든 권한이 1로 설정
111 111 111 -> uamsk 값에 의해 111 111 101
					^~~ umask 가 2이므로 000 000 010 
보안상의 이유로 일반 파일에 대해서는 실행 권한을 제거
110 110 100 -> rw- rw- r-- 로 생성이 되는 것이다.

<Super user, root>
수퍼유저 즉, 관리자 계정을 활성화하는 방법
일반적으로 관리자 아이디는 root로 고정되어있음.
비밀번호 설정 : sudo passwd root 로 할 수 있다.
su (substitute user) 의 약자로 현재 사용자를 로그아웃하지 않고 다른 사용자 계정으로 로그인 하는 명령어
su -l 계정 : 새로운 사용자의 환경을 로드하고 작업 디렉터리를 해당 사용자의 홈 디렉터리로 이동하라는 의미

su -  : 계정이 압묵적으로 root로 설정됨
root 로 로그인시 $ -> #pwd 로 설정됨
하지만 root 로 로그인 시 위험도가 너무 높다. 
따라서 root 로그인 대신 일시적인 root 권한을 얻는 sudo 를 사용한다

<프로세스>
프로그램 : 일반적으로 영구적인 저장 장치에 저장되어 있는 실행 코드
프로세스 : 로더에 의해 프로그램이 주기억 장치에 로드되어 실행되고 있는 것
** 프로그램은 1개이지만, 하나의 프로그램을 여러번 구동하면 프로세스는 1개 이상이 될 수 있음

PID : 운영체제가 다수의 프로세스를 구분하기 위해 부여한 고유번호
ps : 프로세스 아이디를 확인 or 실행중인 프로세스 정보확인
top : 현재 구동중인 프로세스 목록 출력( cpu 점유율 내림차순 출력) 
명령어) q : 종료/ R : 정렬순서 변경 / 1 : 전체 CPU 및 각 CPU 별 사용율 확인

( c 언어에서 main 함수가 호출되기 이전에 linker 에 의해 startup code 가 먼저 실행된다. )

<프로세스의 종료 코드>
? : bash 의 환경변수로 exit 의 값이 저장되는 변수이다.
-> exit를 실행한 프로세스를 종료하면서 ? 에 종료값 설정
(프로세스 종료시 ? 안에 자신의 상태값을 저장한다) 확인하는방법 : echo $?

exit : 종료 코드를 설정하는 명령어( 종료상태값 저장을 위해 8비트 (0-255) 사용
(0-127) : 정해져 있는 오류코드 (128-255)는 signal 값이 설정된다.
128 + signal_number ex) 128 + 2 = 130 즉, 2번 SIGINT 가 보내진 것이다. 

<시그널> : 서로 다른 프로세스 사이의 통신을 위한 메커니즘
(시그널을 받은 프로세스는 일반적으로 중지된다.)
시그널 종류)
- kill -l : 시그널 종류를 출력한다. (실질적으로 31개 정도만 사용한다)  

<script> : 스크립트는 셸이나 명령행에서 실행되도록 작성된 텍스트 파일
(리눅스에서는 확장자의 개념이 없지만 가독성을 이유로 확장자를 쓴다.)
.sh : script 파일에 가독성을 위해 명시하는 확장자명
-[작성방법]-
1. 셔뱅(shebang) : 스크립트 파일 최상단에 위치
		 : 이 파일을 실행 할 인터프리터를 명시
반드시 #! 로 시작해야 하며 해석할 인터프리터의 절대경로를 명시
주석은 # 으로 시작한다.
실행은 상대경로를 써서 실행할 수 있다. (실행권한이 있어야 할 수 있다.)

<단축키 작성>
키 맵핑 방법 : MPA_MODE 단축키 단축키정의
종류)
nmap : 일반 모드(명령모드) 
imap : 편집 모드 
vmap : 비주얼 모드(블럭이 선택된 상태)

nmap <C-C> <ESC>v:'<,'>normal i# <CR>
nmap <C-X> <ESC>v:'<,'>normal xx<CR>
'<,'>normal : 비주얼 모드에서 해당 행 드래그 후 가장 앞으로 커서를 옮긴다.

<표준 출력>
echo : 문자열 출력 후, 개행을 수행(만약 개행을 원치 않을 경우 -n 옵션을 사용)
printf : 문자열 출력 후 개행을 하지 않음.( 원하는 경우 \n 를 쓴다)

echo "name: $name, age: $age" / printf "name:%s, age:%s\n" $name $age 
( 위 두 명령어는 같은 결과를 출력한다. )

<변수 선언 규칙> : 셸 스크립트는 타입이 존재하지 않는다.
1. 알파벳, 숫자, 밑줄만 사용해야한다.
2. 번수명의 첫 글자는 문자, 밑줄만 와야한다.
3. 공백, 마침표 등은 사용 불가.
c나 java와는 달리 변수를 미리 선언할 필요가 없으며 필요할 때마다 변수를 선언
[변수 셍성 방법]
변수명 = 값 ( 주의! = 기호 앞뒤에 공백이 없어야함.)

<문자열 속성>
-[길이]
expr length 문자열 ex) echo $(expr length 문자열)
${#문자열} ex) echo ${#str}

-[인덱스]
문자열의 인덱스는 1베이스이다.
expr index 문자열 찾는문자열 ex->> echo "$(expr index $str 'h')"

-[문자열 찾기]
expr substr 문자열 찾는인덱스시작 끝 ex) echo "$(expr substr $str 1 4)"
->> 문자열의 시작인덱스-끝인덱스 의 문자를 출력한다.
ex) hello 의 경우 1 3 은 hel 이다.
또는 echo $(문자열:시작:길이값} ex) echo $($str:0:4) -0번부터 4개 출력
echo ${문자열:시작인덱스} 시작 인덱스부터 끝까지

-[문자열 부분 삭제]
- 문자열의 앞부터 일치하는 부분 삭제
ex) str="abcABC123ABCabc" 일 경우
${문자열#패턴} : 문자열의 앞부터 가장 짧게 일치하는 패턴 지우기
echo ${str#a*C} : a - C 까지 가장 짧은 길이 지우기 >> 123ABCabc 출력
${문자열##패턴} : 문자열의 앞부터 가장 길게 일치하는 패턴 지우기
echo ${str##a*c} : a - C 까지 가장 긴 길이 지우기 >> abc
시작이나 끝 지점을 지정 하지 않을 시 처음 or 끝 부분으로 지정된다.

- 문자열의 뒤부터 일치하는 부분 삭제
echo ${str%b*c} : b-c까지 짧은 부분 삭제
문자열 파싱 시작,끝 지점을 지정하지 않을 시 시작,끝 부분부터 파싱한다.

<부분 문자열 치환>
문자열에서 일치하는 부분 문자열을 다른 문자열로 치환
${문자열/패턴/치환문자열} : 문자열에 대하여 처음 일치하는패턴을 치환 문자열로 교체
${문자열//패턴/치환문자열}: 문자열에 대하여 일치하는 모든 패턴을 치환 문자열로 교체
${문자열/#패턴/치환문자열}: 문자열에 대하여 앞에서 일치하는 패턴을 치환 문자열로 교체
${문자열/%패턴/치환문자열}: 문자열에 대하여 뒤에서 일치하는 패턴을 치환 문자열로 교체

<사용자로부터 데이터 받기>
read : 사용자로부터 데이터를 받는다.
- read -p "프롬프르" 저장할변수 ex) read -p "input your name : " name

변수 선언을 안할 시 : 
read -p "input your name:" 
echo  "your name : $REPLY" << $REPLY 에 방금 입력받은 문자가 저장됨
변수를 두개 받을 수 있다.
read -p "input your name" first last
echo "first : $first, last : $last" 
>> 만약 저장할 변수가 두개인데 사용자가 그 이상으로 입력을 할경우?
	-->> 초과된 변수는 마지막 변수가 모두 저장을 한다.
