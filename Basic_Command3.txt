man (manual page 의 약자로 리눅스의 각종 도움말을 볼 수 있다.)
- 사용자 명령어
- Syscall API
- C_Library
- 특수파일(장치관련파일)
- 파일 포맷
- 게임이나 미디어 파일
- 그 외 여러 종류
- 시스템 관리용 명령어


<표준 스트림>
- 리눅스에서 표준 스트림이란 사용자의 터미널(모니터와 키보드가 연결되어 있는 단말기) 사이에 미리 연결된 입출력 통로 또는 흐름
- 터미널의 입출력은 일반적으로 키보드와 모니터를 통해 일어나는데 스트림은 이를 추상화한 개념
- C : stdin, stdout, stderr
- bash: 0(표준입력), 1(표준출력), 2(표준에러)

<리다이렉션(표준 출력 재지정)>
- 셸 에서 제공하는 기능으로 실행되는 명령어에 대하여 표준 스트림을 변경할 수 있는 개념
- 표준 출력 리다이렉션
- 표준 출력 리다이렉션
- 표준 오류 리다이렉션
- 명령어 > 파일명 ex) ls > -la > ls_result.txt 
  ( ls -la 의 결과를 ls_result.txt 로 작성한다. ( 파일이 없을 경우 생성 / 있을 경우 덮어쓰기 )
- 명령어를 실행하는 도중 오류가 발생한 경우, 오류 메시지는 표준 오류 스트림으로 보내고 출력파일은 초기화.
  ( 즉, ls -la 기존에 없는 디렉터리명 > result.txt 를 하면 오류는 터미널에서 출력, result.txt 의 내용은 모두 사라진다. )
  ->> 출력 리다이렉션의 특성으로 기존의 파일있을 경우 기존 파일을 삭제 후 새 파일을 만들기 때문! 
기존 정보를 유지한 채로 새로운 정보를 동일 파일에 넣고 싶다면? 
- >> : 리다이렉션을 두번 하면 된다
ex) date > result.txt , ls -la > result.txt 를 하면 지워진다.
    date > result.txt , ls -la >> result.txt 를 하면 지워지지 않는다.

<비어있는 파일을 생성하는 방법의 차이>
- > 파일명 : 출력 리다이렉션을 이용 ( 기존에 파일이 있어도 생성 )
- touch 파일명 : 파일을 생성하는 명령어  ( 기존에 파일이 있으면 생성이 안됨 )

<오류를 재지정 방법>
- 명령어 2> 파일명 ex) ls dfasasfdsafsdffas 2> error.txt 
  ( 에러스트림(2>)으로 나오는 메시지를 해당 텍스트로 저장한다. ) 
그렇다면..? 표준 오류와 출력 메시지를 모두 하나의 파일로 출력하려면? >& 를 사용하면 된다.

<표준 입력 제지정 > 
- 명령어 < 파일명 ex) cat < result.txt

->> 표준 입출력은 동시에 사용할 수 있다. ( 복사 가능 ) 
- cat < result.txt > result_copy.txt
* 사실 이 경우는 cp 를 쓰면 된다.

< here document >
입력 재지정의 추가적인 형태로 다수의 텍스트를 명령어의 표준 입력으로 동시에 보낼 때 사용
- 명령어 << 식별자(이는 사용자가 원하는 대로) 문자열 문자열 ... 식별자

<파이프 라인> 
- nonamed pipe : 이름없는 파이프
- 어떤 명령어의 출력을 다른 명령어의 입력으로 전송하는 매커니즘
- 명령어1 | 명령어2 [|명령어3 ....] ex) ls | wc -w ->> 현재 디렉터리의 파일 수를 뽑아낸다
- ls 의 출력 결과가 wc의 입력으로 된다.
- tee : 파이프에서 어떤 명령어의 출력을 다른 명령어의 입력과 파일로 동시에 출력하는 명령어
  ex) ls | tee result.txt | wc -w ->> ls | (tee result.txt) | wc -w 로 봐도 무방
	->> 즉, ls - wc 의 연결 통로에 빨대를 꽂아서 result.txt 에도 연결 통로를 생성한 느낌
  result.txt 는 무언가를 출력하는애가 아니므로 ls | result.txt | wc -w 를 하면 wc 에는 어떤 입력도 들어가지 않는다. 따라서 tee를 통해 두 친구들 모드 ls 의 결과를 받을 수 있도록 하는것이다.

- named pipe : 이름있는 파이프
- mkfifo 파일명(파이프이름)
** cat 과 pipe를 통해서 메시지를 보낼 수 있다 ! ( 채팅프로그램 만들기?! )
cat > 파이프이름 ex) cat > myfifo

<리눅스의 확장>
- 셸은 명령어가 입력되면 이를 수행하기 전에 입력된 텍스트에 대해서 전처리를 수행한다.
- 즉, 전처리 과정에서 확장이 일어난다.
- echo *
- echo hello world ....

- 경로명 확장
  -> *, ?, [], ..

- 틸트 확장
  -> ~ 가 현재 사용자의 홈 디렉터리 명으로 확장

- 변수 확장
- 셸은 데이터를 저장하기 위해 변수라는 개념을 제공
  변수명=값 (=연산자 사이에 공백이 오면 안된다. 변수명  =값 등등 공백 불가능)
- 해당 변수의 값을 출력하기 위해서는 변수명 앞에 $ 를 써준다.
  ex) name=1; echo $name;

- 산술확장
- $(()) 를 사용하여 내부 표현식을 결과값으로 확장시킨다
  ex) echo $((1+1)) -> 2 출력

- 명령어 확장
- `` 또는 $()를 이용하여 확장. 
	ex) echo `date` or echo $(date) / ls -l $(which ls) ->ls의 정보 출력

-{}(중괄호) 확장
- 중괄호 안에 표현된 패턴과 일치하는 텍스트 문자열로 확장하는것
- 파일명{패턴} ex) file{a,b,c,d}
** 주의 : 콤마 앞뒤에 공백이 있으면 안됩니다. ex) file{a, b,c,e} << 두개의 명령어로 인식
>> 이 점을 보완하기 위해 단축 표기법을 지원한다._{0,1,2,3,4,5}_ ->> _{0..5}_ >>_1_2_3_4_5_
- 중괄호는 1개 이상 사용 가능  ex) {a..z}{0..9} >> 0a 0b 0c....9x 9y 9z
- 충괄호는 중첩 사용도 가능합니다. ex) echo _{a{1..5},b{6..9}}_ >> _a1_ _a2_ .. _b8_ _b9_
- 연습문제 : 2009년 1월부터 2011 12월 까지 년도_월(yyyy_mm) 형식의 디렉터리를 생성해 보세요
	->> mkdir 20{09..11}_{01..12}

<인용부호>
- 큰 따옴표
- 공백을 출력하기위해, 와일드문자를 출력하기위해, 작은 따옴표를 출력하기 위해
- echo hello,        world 의 경우 출력값은 hello, world 이다.
->> 셸은 토큰을 공백, 탭으로 토큰을 구분한다. 이 후 추가적인 공백 및 탭은 불필요하다 판단하여 제거하기 때문이다.
- 따라서 양 끝을 큰 따옴표로 묶어주면 된다 echo "hello,        world" or echo "*"
->> 와일드 문자도 출력이 가능하다.
- echo it\'s different ->> echo "it's different" -> it's differnt
- 예외) 명령어는 그대로 동작은한다. ex) echo "`date`" or echo "$(date)" 
  ->> echo $(cal) : 셸은 2개 이상의 공백과 탭 그리고 개행을 불필요하다 판단하여 하나의 공백으로 치환한다. 따라서 데이터가 원하는 모양으로 출력되지 않을 수 있다.
  ->>> 따라서 큰따옴표로 묶어야 문자 그대로 형태가 유지되므로 echo "$(cal)" 로 출력해야 한다.
- 예외) 매개변수 치환 또는 확장은 그대로 동작한다. ex) echo "$HOME"
- 예외 백슬래시는 그대로 동작한다. ex) echo "\$HOME" -> $HOME 출력

- 작은 따옴표 
- 공백을 출력하기 위해, 명령어를 문자 그대로 출력하기 위해, 

<백슬래시 확장 문자열>
- echo 에서 백슬래시 확장 문자열을 사용할 때는 -e 옵션을 주고 사용해야한다. 
- 백슬래시는 탈출 문자의 역할 뿐만 아니라 제어 문자를 표현하는데도 사용
- \a : 벨소리
- \b : 백스페이스
- \r : 캐리지 리턴 ( 시작위치로 리턴 )

연습문제 ) .과 .. 을 제외한 숨김파일만 모두 출력
	 - echo .[^.]* // ~ : 홈 디렉터리 , ^ : 여집합 ( 제외 ) 

<탐색>
- 파일 시스템 내의 특정 파일을 탐색 ->> find
- 파일 내의 특정 토큰을 탐색 ->> grep

- find
- 다른 명령들은 하위 디렉터리에 대하여 처리하려면 명시적으로 재귀옵션 (R) 을 사용
- find 명령어의 특징은 별도의 옵션 없이 하위 디렉터리까지 검색.
- 따라서 별도 재귀 옵션을 사용할 필요가 없음
- /dev/null 은 블랙홀이다. 이 경로로 결과를 보내면 영원히 삭제하는거나 다름없다. 2> /dev/null 자주 사용

<< find 의 option >>
- 종류 : 테스트 연산자 액션 옵션
1. test : find의 검색 옵션 일종, 테스트는 여러 가지가 존재하지만 자주 사용되는 항복은 다음과 같다.
- name]
- -name '패턴' : 패턴과 일치하는 파일과 디렉터리를 검색할 때 사용
	ex) -name pattern(메타문자가 포함된 문자열) ->> -name '*.txt'
	( 패턴에서 메타문자 또는 와일드카드 사용시, 전처리가 먼저 실행되므로 와일드카드가 먼저 확장된다. 이를 방지하기 위해 작은 따옴표로 묶어준 후 find가 와일드카드에 해당하는 파일을 찾게 한다. )
- -iname '패턴': -name 과 동일하나 대소문자를 구분하지 않는다.
	ex) 현재 디렉터리에서 확장자가 c 인 파일을 검색하고 싶은 경우
	->> find . -name '*.c'
		 ^~~  현재 디렉터리를 기준으로 검색

- size]
- size N : 크기가 N 인 파일을 검색하는 테스트
ex) size 0 : 빈 파일
type T : T 형식의 파일을 검색
  type의 종류
	- d : 디렉터리
	- f : 일반 파일
	- l : 심볼릭 링크
	- b : 블럭 디바이스 ( 한번에 한 블럭씩 전송 )
	- c : 캐릭터 디바이스 (한번에 한 문자씩 전송 )
	- p : 파이프 ( mkfifo ... )
	- s : 소캣
- empty : 크기가 0인 파일이나 비어있는 디렉터리를 검색하는 옵션
  ex ) find . -name 'log*' -type f -empty : 현재 디렉터리부터 log로 시작하는 타입이 파일인 크기가 비어있는 파일 찾기


2. 연산자(operator) 테스트간의 논리적인 연산은 수행하기 위해 제공되는 기능
- -and, -a: 연산자를 기준으로 양쪽 조건이 참인 경우 검색을 수행 ( default 값이다 )
->>find . -name '*.txt' -type f -empty 의경우 find . -name '*.txt' (and) -type f -empty 이다.

- -or, -o : 연산자를 기준으로 양쪽 조건중 하나라도 참인경우 수행
find . -name '*.c' -or -name '*cpp' -and type f : .c 이거나 .cpp 인 파일 찾기

- -not, -! : 단항 연산자로 이 연산자의 다음으로 오는 조건이 거짓인 경우, 검색을 수행
ex) 확장자가 c 인 일반 파일에 대하여 그 크기가 0이 아닌 파일 
  ->> find . -name '*.c' -type f -! empty

() : 조건과 연산자를 조합한 표현식을 하나로 묶어 처리할 때 사용, 또는 가독성을 위해
** 명령어의 인자로 전달되도록 (전처리되지 않도록 ) 백슬래시를 사용해야 하고 반드시 앞뒤에 공백이 있어야함
ex) find . \( -name '*.c' -or -name '*.cpp' \) -type f
             ^~~~~ 공백, 소괄호앞에 \ 붙이기 ~~~~~^

3. 액션(action) : find 명령어에 대하 결과를 어떻게 처리할 것인가에 대해 결정
- 미리 정의된 액션(pre-defined action)
- 사용자 정의 액션

- 미리 정의된 액션
  - print : 검색 결과를 상대 경로를 포함하여 출력하는 액션, 별도의 액션 설정 또는 사용하지 않으면 참인 표현식에 암묵적 사용.
  - 액션은 기본적으로 참으로 해석된다.
  - find . ->> find . -print
  - find . -name 'log*' -type f -empty ->> find . -name 'log*' -type f -empty -print

  - delete : 검색된 결과를 삭제
  ex) "확장자가 .c 이고 일반 파일이며 크기가 0인 결과에 대해 삭제를 해달라" 는 명령어는
	->> find . -name '*.c' -type f -empty -delete
- 사용자 정의 액션 
  - exec 명령어 : 검색된 결과에 대하여 지정된 명령을 실행하는 액션
	- 확장자가 .c 이고 빈 파일이라면 삭제
	->> 사용 방법 : -exec 명령어 \{} \;  ex) find . -name '*.c' -empty -exec rm \{} \;
	->> find . -name '*.c' -empty -exec rm '{}' ';'
	->> 검색 후 즉시 삭제 -> 삭제하는 rm이 빈번하게 발생한다. 따라서
	->> find . -name '*.c' -empty -exec rm \{} \+ : 검색 조건에 해당하는 .c 파일을 모아뒀다가 마지막에 rm 을 실행한다.

4. 옵션 : 검색의 범위를 설정할 때 사용
- maxdepth level : 테스트와 액션을 실행할 때, 디렉터리의 최대 탐색 깊이를 숫자로 지정 (기준 디렉터리는 1)
주의! 옵션은 반드시 테스트와 액션 전에 사용되어야 함
ex) find . maxdepth 1 -type f --> 현재 디렉터리에서 파일만 검색
ex) find . maxdepth 2 -type f --> 현재 디렉터리에서부터 한단계 하위 디렉터리 까지만 파일만 검색






